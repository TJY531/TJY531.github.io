<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 | 好好学习，天天向上</title><meta name="author" content="星星之火"><meta name="copyright" content="星星之火"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统一、 操作系统概述操作系统定义：是计算机系统最基本、最重要的系统软件，是其它软件的支撑软件。它控制和管理计算机系统的硬件和软件资源，合理组织计算机工作流程，并为用户使用计算机提供公共的和基本的服务。它有以下两个主要目标： 高效性：操作系统允许以更加高效的方式使用计算机系统资源。  方便性：操作系统使得用户使用计算机更加方便   计算机系统的组成：运算器、存储器、控制器、输入设备，输出设备">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://tjy531.com.cn/2023/05/25/%E8%80%83%E7%A0%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="好好学习，天天向上">
<meta property="og:description" content="操作系统一、 操作系统概述操作系统定义：是计算机系统最基本、最重要的系统软件，是其它软件的支撑软件。它控制和管理计算机系统的硬件和软件资源，合理组织计算机工作流程，并为用户使用计算机提供公共的和基本的服务。它有以下两个主要目标： 高效性：操作系统允许以更加高效的方式使用计算机系统资源。  方便性：操作系统使得用户使用计算机更加方便   计算机系统的组成：运算器、存储器、控制器、输入设备，输出设备">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/waibaowebsite.jpg">
<meta property="article:published_time" content="2023-05-25T02:04:41.000Z">
<meta property="article:modified_time" content="2023-05-26T02:51:32.009Z">
<meta property="article:author" content="星星之火">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/waibaowebsite.jpg"><link rel="shortcut icon" href="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/waibaowebsite.jpg"><link rel="canonical" href="http://tjy531.com.cn/2023/05/25/%E8%80%83%E7%A0%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 星星之火","link":"链接: ","source":"来源: 好好学习，天天向上","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-26 10:51:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/waibaowebsite.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="好好学习，天天向上"><span class="site-name">好好学习，天天向上</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-25T02:04:41.000Z" title="发表于 2023-05-25 10:04:41">2023-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-26T02:51:32.009Z" title="更新于 2023-05-26 10:51:32">2023-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/">大学学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/05/25/%E8%80%83%E7%A0%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#post-comment"><span class="waline-comment-count" data-path="/2023/05/25/%E8%80%83%E7%A0%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="一、-操作系统概述"><a href="#一、-操作系统概述" class="headerlink" title="一、 操作系统概述"></a>一、 操作系统概述</h2><h4 id="操作系统定义：是计算机系统最基本、最重要的系统软件，是其它软件的支撑软件。它控制和管理计算机系统的硬件和软件资源，合理组织计算机工作流程，并为用户使用计算机提供公共的和基本的服务。它有以下两个主要目标："><a href="#操作系统定义：是计算机系统最基本、最重要的系统软件，是其它软件的支撑软件。它控制和管理计算机系统的硬件和软件资源，合理组织计算机工作流程，并为用户使用计算机提供公共的和基本的服务。它有以下两个主要目标：" class="headerlink" title="操作系统定义：是计算机系统最基本、最重要的系统软件，是其它软件的支撑软件。它控制和管理计算机系统的硬件和软件资源，合理组织计算机工作流程，并为用户使用计算机提供公共的和基本的服务。它有以下两个主要目标："></a>操作系统定义：是计算机系统最基本、最重要的系统软件，是其它软件的支撑软件。它控制和管理计算机系统的硬件和软件资源，合理组织计算机工作流程，并为用户使用计算机提供公共的和基本的服务。它有以下两个主要目标：</h4><ol>
<li><p>高效性：操作系统允许以更加高效的方式使用计算机系统资源。</p>
</li>
<li><p>方便性：操作系统使得用户使用计算机更加方便</p>
</li>
</ol>
<h5 id="计算机系统的组成："><a href="#计算机系统的组成：" class="headerlink" title="计算机系统的组成："></a>计算机系统的组成：</h5><p>运算器、存储器、控制器、输入设备，输出设备</p>
<h5 id="操作系统与计算机系统："><a href="#操作系统与计算机系统：" class="headerlink" title="操作系统与计算机系统："></a>操作系统与计算机系统：</h5><p>单用户操作系统—&gt;具有并行能力的计算机系统</p>
<h5 id="操作系统的发展过程："><a href="#操作系统的发展过程：" class="headerlink" title="操作系统的发展过程："></a>操作系统的发展过程：</h5><p> 简单计算机系统（无操作系统）、单道批处理系统、多道批处理系统、分时系统、实时系统</p>
<p>单道批处理系统</p>
<img title="" src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/921e5e9822813e0a510c30c1766575231f451502.png" alt="图片1.png" width="202">

<p>单道程序工作示意图</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\8cc2188403b3da9932a5dcccc4abe1b8d8052c04.png" alt="图片2.png"></p>
<p>多道程序工作示意图</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\e85e1e7fcc8f000dcb2098a1d8282b9c2a585645.png" alt="图片3.png"></p>
<h5 id="操作系统的主要功能："><a href="#操作系统的主要功能：" class="headerlink" title="操作系统的主要功能："></a>操作系统的主要功能：</h5><ul>
<li><p>处理机管理</p>
</li>
<li><p>存储管理</p>
</li>
<li><p>设备管理</p>
</li>
<li><p>文件管理</p>
</li>
<li><p>用户接口</p>
</li>
</ul>
<h6 id="处理机管理："><a href="#处理机管理：" class="headerlink" title="处理机管理："></a>处理机管理：</h6><ul>
<li><p>进程控制：基本功能是创建和撤销进程、控制进程状态之间的转换</p>
</li>
<li><p>进程同步：进程同步是指系统对并发执行的进程进行协调，使它们能有条不紊的运行</p>
</li>
<li><p>进程通信：进程通信是指相关进程之间的信息交换</p>
</li>
<li><p>进程调度：指按照一定的调度算法在等待执行的进程中选出其中一个，并为其分配CPU、设置运行环境，使其投入运行</p>
</li>
</ul>
<h6 id="存储管理："><a href="#存储管理：" class="headerlink" title="存储管理："></a>存储管理：</h6><ul>
<li><p>内存分配：为每道程序分配必要的内存空间，提高存储器的利用率，减少空间浪费，在实现内存分配时，可采取静态和动态两种方式</p>
</li>
<li><p>内存保护：内存保护的主要任务是确保每道程序都只在自己的内存空间里运行，防止因一道程序的错误而干扰其它程序，也绝不允许用户程序随意访问操作系统的程序和数据</p>
</li>
<li><p>地址映射：把目标程序中的逻辑地址转换成为内存空间中的物理地址</p>
</li>
<li><p>内存扩充：内存扩充是借助虚拟存储技术，在不增加物理内存空间的前提下，从逻辑上对内存进行扩充，使系统能够运行内存需求量比实际内存更大的作业，或是让更多的作业能够并发执行</p>
</li>
</ul>
<h6 id="设备管理："><a href="#设备管理：" class="headerlink" title="设备管理："></a>设备管理：</h6><ul>
<li><p>缓冲管理：缓冲是指在内存中划出来用作暂时存放信息的一部分区域。在CPU和I&#x2F;O设备之间设置缓冲区，则可以有效缓解速度不匹配的矛盾，提高CPU的利用率，从而提高系统吞吐量</p>
</li>
<li><p>设备分配：根据用户所请求的设备类型、数量，按照一定分配算法对设备进行分配</p>
</li>
<li><p>设备处理：设备处理程序又称为设备驱动程序，其基本任务是由CPU向设备控制器发出I&#x2F;O命令，启动指定的I&#x2F;O设备、完成用户规定的I&#x2F;O操作，并对设备发来的中断请求进行及时响应和处理。</p>
</li>
<li><p>虚拟设备管理：虚拟设备也称逻辑设备，是指操作系统通过设备虚拟技术，把每次仅供一个进程使用的独享设备改造成能被多个用户使用的设备</p>
</li>
</ul>
<h6 id="文件管理-："><a href="#文件管理-：" class="headerlink" title="文件管理 ："></a>文件管理 ：</h6><ul>
<li><p>文件存储空间管理：一些当前需要使用的系统文件和用户文件，都必须放在可随机存取的磁盘上。为此，必须由操作系统统一对文件的存储空间进行管理，提高存储空间的利用率，同时也提高文件系统的存取速度</p>
</li>
<li><p>目录管理：目录又称文件目录，是用来描述系统中所有文件基本情况的一个表。为了使用户能够方便的在外存上找到自己所需的文件，系统会为每个文件建立一个目录项。在不同的系统中，目录有着不同的组织方式</p>
</li>
<li><p>文件读写管理：对文件进行读写操作，是文件管理必须具备的最基本的操作。该功能可以根据用户的请求，从外存指定区域把指定数量的信息读入到内存指定的用户区或系统区，或将指定数量的信息从内存写入外存指定区域。</p>
</li>
<li><p>文件保护：为了防止系统中的文件被非法窃取和破坏，必须提供有效的存取控制机制</p>
</li>
<li><p>文件系统的安全性：是指文件系统避免因软件或硬件故障而造成信息破坏的能力</p>
</li>
</ul>
<h6 id="用户接口："><a href="#用户接口：" class="headerlink" title="用户接口："></a>用户接口：</h6><ul>
<li><p>命令接口：为了便于用户直接或间接控制自己的作业，操作系统向用户提供了命令接口。用户可以通过该接口向作业发出命令，以控制作业的运行。 </p>
</li>
<li><p>程序接口：该接口是为用户程序在执行过程中访问系统资源而设定的，是用户程序取得操作系统服务的唯一途径。程序接口是由一组系统调用组成，每当应用程序要求操作系统提供某种类型的服务时，便调用具有相应功能的系统调用。 </p>
</li>
<li><p>图形接口：采用图形化的操作界面，用非常容易识别的图标将系统的各种命令直观、逼真的表示出来，用户通过简单的点击鼠标，借助菜单、对话框，就可以完成对应用程序和文件的操作，极大的方便了用户的使用。</p>
</li>
</ul>
<h5 id="操作系统结构："><a href="#操作系统结构：" class="headerlink" title="操作系统结构："></a>操作系统结构：</h5><p> 单体、模块化、可扩展内核、层次结构</p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/a3f06f8a7a194691060f877f7915d1595327bf2c.png" title="" alt="图片4.png" width="254">

<img title="" src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/097907d2de1ead3a9fa0461e76a48795371d091a.png" alt="图片5.png" width="253">

<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/76f88575b562e5d8e2410eadd6f5b3ea0ec50072.png" title="" alt="图片6.png" width="254">

<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/15c7167f15575e2169557a4731e926fba26b7e97.png" title="" alt="图片7.png" width="257">

<h4 id="操作系统的特性-：并发、共享、虚拟和异步"><a href="#操作系统的特性-：并发、共享、虚拟和异步" class="headerlink" title="操作系统的特性 ：并发、共享、虚拟和异步"></a>操作系统的特性 ：并发、共享、虚拟和异步</h4><ul>
<li><p>并发性：<strong>是指在一段时间内有多道程序同时在计算机内运行</strong></p>
</li>
<li><p>共享性：互斥共享，是指该类资源的分配必须以作业（或进程）为单位，在一个作业（或进程）没有运行完之前，另一个作业（或进程）不得使用该类资源；“同时”共享，是指多个作业（或进程）可“同时”使用该类资源，这里的“同时”和并发性中的“同时”有着相同的含义</p>
</li>
<li><p>虚拟性：操作系统的虚拟性是指操作系统使用某种技术，将物理上的一个资源或设备变成逻辑上的多个资源或设备。虚拟出来的东西不过是用户的“错觉”，并不是客观存在的东西</p>
</li>
<li><p>异步性：操作系统的异步性又称之为不确定性，不是说操作系统本身的功能不确定，也不是说在操作系统控制下运行的用户程序的结果是不确定的。<strong>异步性指在操作系统控制下的多个作业的执行顺序和每个作业的执行时间是不确定的，即进程是以人们不可预知的速度向前推进</strong></p>
</li>
</ul>
<p>操作系统的新特征：微内核体系结构、多线程、对称多处理、分布式操作系统、面向对象设计</p>
<h2 id="二、中断"><a href="#二、中断" class="headerlink" title="二、中断"></a>二、中断</h2><h5 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h5><p>所谓中断，就是指CPU在执行一个程序时，对系统发生的某个事件（程序自身或外界的原因引起的）会做出的一种反应，<strong>即CPU暂停正在执行的程序，保留当前程序的运行现场后自动转去处理相应的事件，处理完该事件后，又返回到之前的程序断点，继续执行被中断的程序。</strong></p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/f68261117259b228a237710e34f1530b1af0682a.png" title="" alt="图片8.png" width="263">

<p>中断的特点：随机性、可恢复性、自动性</p>
<p>中断优先级：硬件故障中断&gt;自愿性中断&gt;程序性中断&gt;外部中断&gt;输入&#x2F;输出中断</p>
<h5 id="中断的响应过程"><a href="#中断的响应过程" class="headerlink" title="中断的响应过程"></a>中断的响应过程</h5><ul>
<li>发现中断源</li>
</ul>
<img title="" src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/6ecdde332ade5b5db9c6bfbb9818d9c99a4825fb.png" alt="图片9.png" data-align="center" width="348">

<ul>
<li><p>保护和恢复现场：现场是指在中断的那一时刻能确保程序继续运行的有关信息。 为了确保被中断的程序能从恢复点继续运行，必须在该程序重新运行之前，把保留的该程序的现场信息从主存中送至相应的各个寄存器当中，把完成这些工作称为恢复现场。 </p>
</li>
<li><p>中断响应：中断响应是当CPU发现已有中断请求时，终止现行程序的执行，并自动引出中断处理程序的过程。 当发生中断事件时，中断系统必须立即将程序断点的现场信息存放到主存约定单元进行保存，用于中断返回时恢复现场使用。<strong>中断响应的实质就是交换用户程序和相应中断处理程序的指令执行地址和处理器状态，以达到保存断点和自动执行中断处理程序的目的。</strong></p>
</li>
</ul>
<h4 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h4><h6 id="保护现场和传递参数"><a href="#保护现场和传递参数" class="headerlink" title="保护现场和传递参数"></a>保护现场和传递参数</h6><p>  对现场进行保护，包括对断点的保护和对通用寄存器以及状态寄存器的保护。  </p>
<h6 id="执行相应的中断服务程序"><a href="#执行相应的中断服务程序" class="headerlink" title="执行相应的中断服务程序"></a>执行相应的中断服务程序</h6><p> 针对响应的中断事件，执行处理该事件的中断服务程序。</p>
<h6 id="恢复现场并退出中断"><a href="#恢复现场并退出中断" class="headerlink" title="恢复现场并退出中断"></a>恢复现场并退出中断</h6><p>  执行完中断处理程序，系统要返回到之前的断点处继续执行，所以要将先前保存的断点信息重新加载进系统的各个寄存器当中，并将中断屏蔽字还原，这一过程称为恢复现场。</p>
<img title="" src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/36fbb2f2437942005cdbd79ca0e2c8162e195356.png" alt="图片10.png" width="292" data-align="center">

<h2 id="三、-进程和线程"><a href="#三、-进程和线程" class="headerlink" title="三、 进程和线程"></a>三、 进程和线程</h2><h6 id="程序的顺序执行及其特征："><a href="#程序的顺序执行及其特征：" class="headerlink" title="程序的顺序执行及其特征："></a>程序的顺序执行及其特征：</h6><p>通常可以把一个应用程序分成若干个程序段，各程序段之间必须按照某种先后次序顺序执行，仅当前一程序段（操作）执行完后，才能执行后继程序段（操作）。</p>
<p>特征：顺序性、封闭性、可再现性</p>
<h6 id="程序的并发执行及其特征："><a href="#程序的并发执行及其特征：" class="headerlink" title="程序的并发执行及其特征："></a>程序的并发执行及其特征：</h6><p>为了提高计算机的利用率、处理速度和系统的吞吐量，并行处理技术和并发程序设计技术在计算机中已经得到了广泛应用，成为了现代操作系统的基本特征之一。</p>
<p>特征：异步性、失去封闭性、不可再现性</p>
<h4 id="进程的概念及其特征：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。"><a href="#进程的概念及其特征：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。" class="headerlink" title="进程的概念及其特征：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。"></a>进程的概念及其特征：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</h4><p>程序和进程之前的区别和联系：</p>
<p>程序是完成特定任务的一组指令的结合，可以永久保存，具有静态性；<br>进程是程序在某一数据结构上的一次执行过程，是系统进行资源分配和调度的基本单位，具有动态性；<br>一个进程可以包含多个程序，一个程序也可以被多个进程执行。</p>
<h4 id="进程状态："><a href="#进程状态：" class="headerlink" title="进程状态："></a>进程状态：</h4><h5 id="两状态模型"><a href="#两状态模型" class="headerlink" title="两状态模型"></a>两状态模型</h5><p>包含运行态（Running）和非运行态（Not running）两种进程状态<br>创建了一个新进程之后，它会以非运行态加入到系统中，等到操作系统为其分派处理器<br>当前处于运行态的进程会不时地中断，由系统中的分派器选择处于非运行状中的某一个进程运行</p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/8f7f7f67590b9d22d3b6b5ce741de687515c5703.png" title="" alt="图片11.png" width="404">

<h5 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h5><p>包括<strong>就绪态</strong>（Ready）、<strong>运行态</strong>（Running）、<strong>阻塞态</strong>（Blocked）、<strong>新建态</strong>（New）和<strong>终止态</strong>（Terminate）<br>进程状态描述：<br>    （1）新建态：刚刚创建的新进程，通常是指进程控制块已经创建，但还没有加载到系统内存中的进程。<br>    （2）就绪态：进程等待系统为其分派处理器，而此时处理器被其它进程占据，所以该状态进程不能执行，但已经具备了除处理器之外的进程执行所需要的所有条件。</p>
<p>    （3）运行态：进程已获得所需资源并占据处理器，处理器正在执行该进程。<br>   （4）阻塞态：也称为等待态、挂起态或睡眠态，进程在等待某个事情的发生而暂时不能运行，例如等待某个I&#x2F;O操作的完成。<br>   （5）终止态：进程或者因为执行结束或者因为被撤销而从可执行进程组中退出。</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\19ca50a1cec642b400724b7ae3d1cbc3ca966f38.png" alt="图片12.png"></p>
<h5 id="引入挂起状态"><a href="#引入挂起状态" class="headerlink" title="引入挂起状态"></a>引入挂起状态</h5><p>      对于内存中的多个进程，处理器依次选中运行，当一个进程正在等待I&#x2F;O事件发生时，处理器转移到另一个进程。但是，处理器的速度比I&#x2F;O要快很多，有可能内存中所有进程都在等待I&#x2F;O事件的完成，导致处理器处于空闲状态。<br>     引入挂起（Suspend）的概念：内存中没有就绪的进程时，系统将内存中处于阻塞的进程换出到外存中的挂起队列，而将外存中的就绪进程激活，换入到内存</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\204ce929ebdf54c0baf2f91927f7c4bed6de3eaf.jpg" alt="图片13.jpg"></p>
<h6 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h6><p>进程控制块（Process control block, PCB）是操作系统用来记录进程状态和相关信息，控制进程运行的数据结构，是进程的唯一标识符</p>
<h6 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h6><p>进程控制是进程管理中最基本的功能<br>在操作系统中，不同功能都是通过执行各种原语（Primitive）操作实现<br>原语是由若干条指令构成、可完成特定功能的程序段</p>
<h6 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h6><p>在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量。<br>在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使操作系统具有更好的并发性。<br>通常把调度和分派的基本单位称做线程或轻量级进程（Light weight process, LWP）,而把资源分配的基本单位称做进程或者任务。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>进程在任一时刻只有一个执行控制流，通常将这种结构的进程称为单线程进程（Single threaded process）。<br>多线程进程（Multiple threaded process）——同一进程中设计出多条控制流，并且满足：<br>   （1）多控制流之间可以并行执行；<br>   （2）多控制流切换不需通过进程调度；<br>   （3）多控制流之间可以通过内存直接通信联系，从而降低通信开销。</p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/a116731aebd5813540005d33074ea7b3acb466bf.png" title="" alt="图片13.png" width="481">

<h6 id="线程实现与线程模型"><a href="#线程实现与线程模型" class="headerlink" title="线程实现与线程模型"></a>线程实现与线程模型</h6><p>用户级线程（User level thread, ULT）<br>            线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</p>
<p>内核级线程（Kernel level thread, KLT）<br>            线程管理的所有工作都是由内核完成，应用程序并没有参与其中。即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、终止和切换等也是依靠内核，在内核空间实现的。</p>
<p>组合方式<br>            同一个进程内的多个线程可以同时在多处理器上并行执行，而且一个线程被阻塞时，同一进程内的其它线程可以调度运行，并不需要阻塞整个进程。所以，组合方式多线程机制能够结合KLT和ULT两者的优点，并克服了其各自的不足。</p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/dbd834c4e5bc4f014a46c799787cd50f1bdc0482.png" title="" alt="图片14.png" width="448">

<h6 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h6><p>多对一模型</p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/fc511176f52c39d2b6445148979c3023742c2c97.png" title="" alt="图片15.png" width="394">

<p>一对一模型</p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/b89bc2be5d9bf184ed46dc23f1db2a38f9567311.png" title="" alt="图片16.png" width="467">

<p>多对多模型</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\29d6d8f501541eab2d4006f9573b04d750d50edb.png" alt="图片17.png"></p>
<h4 id="并发原理：临界资源、临界区等多种术语"><a href="#并发原理：临界资源、临界区等多种术语" class="headerlink" title="并发原理：临界资源、临界区等多种术语"></a>并发原理：临界资源、临界区等多种术语</h4><h6 id="临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行"><a href="#临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行" class="headerlink" title="临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行"></a>临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行</h6><h6 id="竞争-：多个进程在访问一个共享数据时，结果依赖于它们执行的相对时间，这种关系称为竞争"><a href="#竞争-：多个进程在访问一个共享数据时，结果依赖于它们执行的相对时间，这种关系称为竞争" class="headerlink" title="竞争 ：多个进程在访问一个共享数据时，结果依赖于它们执行的相对时间，这种关系称为竞争"></a>竞争 ：多个进程在访问一个共享数据时，结果依赖于它们执行的相对时间，这种关系称为竞争</h6><h6 id="同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步"><a href="#同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步" class="headerlink" title="同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步"></a>同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步</h6><h6 id="互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源"><a href="#互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源" class="headerlink" title="互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源"></a>互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源</h6><h6 id="死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁"><a href="#死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁" class="headerlink" title="死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁"></a>死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁</h6><h6 id="饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况"><a href="#饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况" class="headerlink" title="饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况"></a>饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况</h6><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> TestAndSet指令实现互斥的示例如下：</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TestAndSet(&amp;lock))</span><br><span class="line">           ;<span class="comment">// do nothing</span></span><br><span class="line">  <span class="comment">// critical section</span></span><br><span class="line">  lock = FALSE;</span><br><span class="line">  <span class="comment">// remainder section</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line"></span><br><span class="line"> .Swap指令</span><br><span class="line">Swap指令为对换指令，定义如下：</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(boolean *a, boolean *b)</span>&#123;</span><br><span class="line">  Boolean temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 使用Swap指令实现互斥的示例如下：</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  data = TRUE;</span><br><span class="line">  <span class="keyword">while</span>(data == TRUE)</span><br><span class="line">    Swap(&amp;lock, &amp;data);</span><br><span class="line">  <span class="comment">// critical section</span></span><br><span class="line">  lock = FALSE;</span><br><span class="line">  <span class="comment">// reminder section</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE);</span><br></pre></td></tr></table></figure>

<h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p><strong>整型信号量</strong><br>           Dijkstra把整型信号量s定义成一个用于表示资源数目的整型变量。进程通过信号量传送信号，利用两个特殊的操作发送和接收信号。<br>   signal(s)：通过信号量s传送信号<br>   wait(s)：   通过信号量s接收信号<br>   如果相应的信号仍然没有发送，则进程被挂起，直到发送完为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait()操作定义如下</span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(s)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(s&lt;=<span class="number">0</span>)</span><br><span class="line">     ; <span class="comment">//do nothing</span></span><br><span class="line">   s--;</span><br><span class="line">&#125;</span><br><span class="line">signal()操作定义如下</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(s)</span>&#123;</span><br><span class="line">  s++;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>记录型信号量</strong><br>整型信号量机制没有满足让权等待的原则，可能使进程处于饥饿的忙等状态。<br>假设s为一个记录型数据结构，其中一个分量为整形量value，另一个为信号量队列queue。value通常是一个具有非负初值的整型变量，queue是一个初始状态为空的进程队列，当一个进程必须等待信号量时，就加入到进程队列中去。</p>
<p>wait和signal操作定义如下：<br>       wait(s)：信号量s减l，若结果小于0，则调用wait(s)的进程被设置成等待信号量s的状态。<br>      signal(s)：将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> 记录型信号量数据结构定义如下：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">QueueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"> wait( )操作定义如下：</span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore *s)</span>&#123;</span><br><span class="line">  s.value--;</span><br><span class="line">  <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    block(s.<span class="built_in">queue</span>); <span class="comment">// add this process into s.queue</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">signal( )操作定义如下：</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore *s)</span>&#123;</span><br><span class="line">  s.value++;</span><br><span class="line">  <span class="keyword">if</span>(s.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">   wakeup(s.<span class="built_in">queue</span>); <span class="comment">// remove a process from s.queue</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">（<span class="number">1</span>）若信号量s.value值为正，</span><br><span class="line"> 则该值表示在对进程进行阻塞之前对信号量s可以实施的wait()操作个数，</span><br><span class="line"> 即系统中某类资源实际可用数目；</span><br><span class="line">（<span class="number">2</span>）若信号量s.value值为负，</span><br><span class="line"> 则其绝对值表示阻塞队列s.<span class="built_in">queue</span>中等待的进程个数；</span><br><span class="line">（<span class="number">3</span>）每次wait()操作，意味着进程请求一个单位的该类资源，</span><br><span class="line"> 使系统中可供分配的该类资源数减少一个，每次signal()操作，</span><br><span class="line"> 表示执行进程释放一个单位资源，使系统中可供分配的该类资源数增加一个。</span><br></pre></td></tr></table></figure>

<p><strong>二元信号量</strong><br>假设s为一个记录型数据结构，其中一个分量为value，它仅能取值0和1，另一个分量为信号量队列queue。<br>一个二元信号量的值只能是0或者1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>zero, one&#125; value; </span><br><span class="line">QueueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;binary_semaphore;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitB</span><span class="params">(binary_semaphore *s)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.value == one)</span><br><span class="line">     s.value = zero;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     block(s.<span class="built_in">queue</span>); <span class="comment">// add this process into s.queue</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signalB</span><span class="params">(binary_semaphore *s)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty())&#123;</span><br><span class="line">     s.value = one;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    wakeup(s.<span class="built_in">queue</span>); <span class="comment">// remove a process from s.queue</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用信号量实现进程互斥</strong></p>
<p>多个进程互斥地访问某临界资源，只需为该资源设置互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区置于wait(mutex)和signal(mutex)操作之间即可。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line">     PA() &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">             wait(mutex);</span><br><span class="line">             临界区</span><br><span class="line">             signal(mutex);</span><br><span class="line">             剩余区</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">    PB () &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">             wait(mutex);</span><br><span class="line">             临界区 </span><br><span class="line">             signal(mutex);</span><br><span class="line">             剩余区</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用信号量实现前趋关系</strong></p>
<p>还可利用信号量来描述程序或语句之间的前趋关系。设有两个并发执行的进程P1和P2。P1中有语句S1；P2中有语句S2。我们希望在S1执行后再执行S2。为实现这种前趋关系，只需使进程P1和P2共享一个公用信号量S，并赋予其初值为0，将signal(S)操作放在语句S1后面，而在S2语句前面插入wait(S)操作，即<br>　　在进程P1中，用S1；signal(S)；　　</p>
<p>          在进程P2中，用wait(S)；S2；</p>
<p>由于S被初始化为0，这样，若P2先执行必定阻塞，只有在进程P1执行完S1； signal(S)；操作后使S增为1时，P2进程方能成功执行语句S2</p>
<h6 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h6><p>        管程是由一个或多个过程、一个初始化序列和数据组成的软件模块，是一种程序设计语言结构成分，具有和信号量同等的表达能力。进程可以通过调用管程实现对资源的请求和释放。</p>
<p>cwait和csignal操作意义：<br>   （1）cwait(c)操作：正在调用管程过程的进程因条件c没有满足而被阻塞或者挂起，则调用cwait操作将自己插入到条件变量c的等待进程队列中。与此同时，被阻塞进程释放管程，直到条件c发生改变，其它进程可以调用管程。<br>   （2）csignal(c)操作：正在调用管程的进程检测到条件c发生了改变，则调用csignal操作重新唤醒一个因条件c而被阻塞或者挂起的进程。如果等待进程队列中有多个进程，则选择其中一个唤醒，否则继续执行原进程。</p>
<h4 id="三个经典的进程同步问题"><a href="#三个经典的进程同步问题" class="headerlink" title="三个经典的进程同步问题"></a>三个经典的进程同步问题</h4><h6 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h6><p>问题描述<br>        假设有n个生产者和m个消费者，连接在一个有k个公用缓冲区的有界缓冲上，pi表示生产者进程，cj表示消费者进程。 满足：<br>只要缓冲区未满，生产者pi即可将生产的产品放 入空闲缓冲区中<br>只要缓冲区不为空，消费者进程cj就可从缓冲区从取走并消耗产品</p>
<p>用信号量解决生产者-消费者问题<br>利用互斥信号量mutex实现多个进程对公用缓冲区的互斥使用，初始化为1<br>利用信号量empty和full分别记录公用缓冲区中空缓冲区和满缓冲区的个数，分别初始化为k和0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nextin = <span class="number">0</span>, nextout = <span class="number">0</span>;</span><br><span class="line">item buffer[k];</span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = k, full = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">      <span class="comment">//produce an item in nextp;</span></span><br><span class="line">      wait(empty);</span><br><span class="line">      wait(mutex);</span><br><span class="line">      buffer[nextin] = nextp;</span><br><span class="line">      nextin = (nextin + <span class="number">1</span>) % k;</span><br><span class="line">      signal(mutex);</span><br><span class="line">      signal(full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">         wait(full);</span><br><span class="line">         wait(mutex);</span><br><span class="line">         nextc = buffer[nextout];</span><br><span class="line">         nextout = (nextout + <span class="number">1</span>) % k;</span><br><span class="line">         signal(mutex);</span><br><span class="line">         signal(empty);</span><br><span class="line">         <span class="comment">//consume the item in nextc;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  parbegin (producer, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h6><p>问题描述<br>        有一个多个进程共享的数据区，我们把只要读该数据区的进程记为Reader进程（读者），把只要往数据区中写数据的进程记为Writer进程（写者）。满足：<br>允许多个读者同时执行读操作<br>一次只能有一个写者可以执行写操作<br>如果一个写者在执行写操作，则其它任何读者都不能执行读操作</p>
<p>用信号量解决读者-写者问题</p>
<p>利用互斥信号量wmutex实施读者与写者在读写时的互斥，<br>设置整型变量readercount用于记录正在读的进程个数<br>计数变量readercount本身是可以被多个读者访问的临界资源，设置互斥信号量mutex控制多个读者对readercount的修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>, wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readercount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)</span><br><span class="line">&#123;</span><br><span class="line">  wait(mutex);</span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)</span><br><span class="line">    wait(wmutex);</span><br><span class="line">  readercount++;</span><br><span class="line">  signal(mutex);</span><br><span class="line">  <span class="comment">// read operation</span></span><br><span class="line">  wait(mutex);</span><br><span class="line">  readercount--;</span><br><span class="line"><span class="keyword">if</span> (readcount == <span class="number">0</span>)</span><br><span class="line">    signal(wmutex);</span><br><span class="line">        signal(mutex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(wmutex);</span><br><span class="line">    <span class="comment">// write operation</span></span><br><span class="line">    signal(wmutex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  parbegin (reader, writer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h6><p>问题描述<br>        有五位哲学家，用一生来思考和吃饭。他们围坐在一张圆桌旁边，桌子中央有一大碗米饭，桌上还有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，当某位哲学家进行思考时，他不与其它哲学家交互。当他感觉到饥饿时，便试图拿起与其左右最靠近他的筷子。满足：<br>一个哲学家每次只能拿起一只筷子，且他不能从其他哲学家手里拿筷子<br>只有在他拿到两只筷子时才能进餐</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore room = &#123;<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span> <span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">// think</span></span><br><span class="line">    wait(room);</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    <span class="comment">// eat</span></span><br><span class="line">    signal(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(room);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  parbegain (philosopher(<span class="number">0</span>), philosopher(<span class="number">1</span>), philosopher(<span class="number">2</span>), philosopher(<span class="number">3</span>), philosopher(<span class="number">4</span>));&#125;</span><br></pre></td></tr></table></figure>

<h6 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h6><p>消息传递（Message passing）作为当前应用最为广泛的一种进程间通信机制，为进程间信息传递和交换的实现提供了很好的保障<br>消息是一组信息，由消息头和消息体组成。<br>send(destination, message)<br>receive(source, message)</p>
<h2 id="四、处理机调度"><a href="#四、处理机调度" class="headerlink" title="四、处理机调度"></a>四、处理机调度</h2><h6 id="调度简介"><a href="#调度简介" class="headerlink" title="调度简介"></a>调度简介</h6><p>计算机系统中，处理器和内存资源会出现供不应求的情况，特别是多个I&#x2F;O设备与主机交互，作业不断进入系统，或者是多个批处理作业在磁盘的后备队列中等待进入内存的情况。操作系统在管理有限的资源的同时，需要考虑如何选取进入内存的作业，如何分配有限的处理器资源给多个进程等重要问题。处理器的调度正是处理器和内存资源调度和分配相关的工作。</p>
<p>高级调度：对象是作业，又称作业调度、长调度</p>
<p>低级调度：对象是进程，又称进程调度、短调度</p>
<p>中级调度：中级调度介于高级调度和低级调度之间。该调度根据进程状态决定辅存和主存之间的进程对换。主存资源紧缺时，将暂时不能运行的进程换出，进程转为挂起状态；主存资源空闲，并且进程满足运行条件时，再将进程调回主存。对主存的利用和系统吞吐率都有很大的提升。</p>
<p>在上述三种调度中，进程调度是操作系统最核心的部分，运行频率最高，因此把它称为短程调度。为避免进程调度占用太多的CPU时间，进程调度算法不宜太复杂。作业调度往往是发生在一个(批)作业运行完毕，退出系统，而需要重新调入一个(批)作业进入内存时，故作业调度的周期较长，大约几分钟一次，因此把它称为长程调度。在纯粹的分时或实时操作系统中通常不需要作业调度。中级调度的运行频率基本上介于上述两种调度之间。一些功能完善的操作系统为了提高主存利用率和作业吞吐率，会引入中级调度。</p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><strong>先来先服务调度算法</strong></p>
<p>先来先服务算法（First Come First Served， FCFS）按照作业&#x2F;进程进入队列的先后顺序进行挑选，先进入的将优先进行后续步骤。该算法既可用于高级调度，也可用于低级调度。当在高级调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在低级调度中采用该算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。该算法比较有利于长作业(进程)，而不利于短作业(进程)。</p>
<p><strong>短作业优先调度算法</strong></p>
<p>短作业优先调度算法（shot job first, SJF）按照进入系统的作业所要求的CPU运行时间的长短为挑选依据，优先选取预计计算时间最短的作业。可以分别用于高级调度和低级调度。</p>
<p>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。SJF调度算法能有效地降低作业的平均等待时间，提高系统吞吐量。</p>
<p><strong>优先级算法</strong></p>
<p>优先级算法根据事先设定好的进程的优先级来选取就绪队列中优先级最高的进程投入运行。在运行过程中，如果就绪队列中出现优先级更高的进程，则根据系统的策略：抢占式或非抢占式进行调度 </p>
<p>非抢占式：当前进程继续运行直到完成；或出现需要等待的事件放弃处理机，再调度优先级高的进程运行。<br>抢占式：当前进程占用的处理机被立即剥夺，将处理机分配给优先级高的进程，使之运行。只要高优先级的进程出现，无论当前进程完成与否，都必须立即停止，重新将处理机分配给新到的优先权最高的进程。抢占式的优先级调度算法能更好地满足紧迫作业的要求。</p>
<p><strong>时间片轮转算法</strong></p>
<p>时间片轮转算法将CPU分配给就绪队列中的第一个进程，每次分配一个时间片。但时间片耗尽时，如果进程未完成，则让出处理机，转到就绪队列的队尾，等待下一轮的时间片的分配。<br>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把处理机分配给队首进程，并令其执行一个时间片。当执行的时间片用完时发出中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证系统能在给定的时间内响应所有用户的请求。</p>
<p>在时间片轮转算法中，时间片的大小对系统性能有很大的影响<br>选择很小的时间片将有利于短作业，因为它能较快地完成，但会频繁地发生中断、进程上下文的切换，从而增加系统的开销<br>选择太长的时间片，使得每个进程都能在一个时间片内完成，时间片轮转算法便退化为FCFS算法，无法满足交互式用户的需求<br>一个较为可取的大小是时间片略大于一次典型的交互时间，这样可使大多数进程在一个时间片内完成</p>
<p><strong>高响应比优先算法</strong></p>
<p>最高响应比优先算法同时兼顾作业的等待时间和处理时间，做有效的协调和折中，既能照顾短作业的调度，同时也不会让长作业等待的时间超出合理的范围。</p>
<p><strong>几种算法比较</strong></p>
<p>先来先服务：只考虑作业等待时间，忽视作业计算时间。<br>短作业优先：考虑作业预计的计算时间，忽视作业的等待时间。<br>最高响应比：综合前两种算法的优点：既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。缺点：计算每个作业的响应比需要耗费一定的时间，性能比短作业优先算法略差。<br>如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以一定的速率提高，则长作业在等待一定的时间后，必然有机会分配到处理机。</p>
<p>高响应比调度算法：<br>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业<br>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而实现的是先来先服务　<br>对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机</p>
<h6 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h6><p>计算机系统中存在一些只能被一个进程所使用的资源，如磁带机、打印机等独占设备。<br>两个进程同时进入临界区会导致数据错误或者系统错误。所以操作系统需要控制进程独立对这些临界资源进行访问。<br>对资源的访问需要以下步骤：申请，访问，归还。如果某一个进程申请资源的时候，资源正在被其他进程使用，则该申请的进程需要等待。</p>
<p>资源可以分成如下两类：<br>可剥夺性资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。如：处理机和内存。优先权高的进程可以剥夺优先权低的进程的处理机。内存区可由存储器管理程序把一个进程从一个存储区移到另一个存储区，此即剥夺了该进程原来占有的存储区。甚至可将一个进程从内存调出到外存上。<br>不可剥夺性资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。 </p>
<h4 id="死锁产生的原因和必要条件"><a href="#死锁产生的原因和必要条件" class="headerlink" title="死锁产生的原因和必要条件"></a>死锁产生的原因和必要条件</h4><h6 id="死锁的定义：所谓死锁-Deadlock-，是指多个进程因竞争资源而造成的一种僵局-Deadly-Embrace-，若无外力作用，这些进程将永远不能再向前推进。"><a href="#死锁的定义：所谓死锁-Deadlock-，是指多个进程因竞争资源而造成的一种僵局-Deadly-Embrace-，若无外力作用，这些进程将永远不能再向前推进。" class="headerlink" title="死锁的定义：所谓死锁 (Deadlock)，是指多个进程因竞争资源而造成的一种僵局(Deadly-Embrace)，若无外力作用，这些进程将永远不能再向前推进。"></a>死锁的定义：所谓死锁 (Deadlock)，是指多个进程因竞争资源而造成的一种僵局(Deadly-Embrace)，若无外力作用，这些进程将永远不能再向前推进。</h6><p><strong>死锁产生的必要条件</strong></p>
<p><strong>互斥</strong>: 进程对所分配到的资源必须独立使用，即在一段时间内某资源只由一个进程占用，不能共享。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程使用完毕，对资源进行释放。<br><strong>请求和保持</strong>：进程已经持有了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已获得的其它资源保持继续持有。<br><strong>不可剥夺</strong>: 在未使用完之前，不能剥夺进程已获得的资源，只能在使用完时由自己释放。<br><strong>循环等待</strong>：在发生死锁时，必然存在一个进程和进程之间等待相互资源的环形链。使得链中每个进程的资源需求都得不到满足。</p>
<h6 id="死锁的表示方法和判定"><a href="#死锁的表示方法和判定" class="headerlink" title="死锁的表示方法和判定"></a>死锁的表示方法和判定</h6><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/ba475bbc57a61b0e81bca5148491b7345f315a03.png" title="" alt="图片18.png" width="424">

<p>根据SRAG的定义，可以使用以下规则判定死锁<br>如果SRAG中无环路，则系统不会死锁。<br>如果SRAG中有环路，且处于此环中的每类资源只有一个，如图4.7(c)所示，则系统出现死锁。此时，环是系统存在死锁的充分必要条件。<br>如果SRAG中有环路，但是处于此环中的每类资源的个数不全为1，如图4.7(d)所示，则系统不一定会发生死锁。此时，环只是产生死锁的必要条件而不是充分条件。<br>系统存在死锁状态的充要条件是当且仅当系统的SRAG是不可完全简化的。如果资源满足某个进程的要求，则在SRAG中消去此进程的所有请求边和分配边，使其成为孤立结点。对所有进程执行该操作。如果所有进程都成为孤立结点，则称该图是可完全简化的；否则称该图是不可完全简化的。</p>
<h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><p>破坏“请求和保持”条件<br>请求：将对资源的申请放在进程运行之前一次性进行，得到了所需所有资源的进程在整个运行期间不会再提出资源要求，从而破坏了请求条件。<br>分配：在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需的各资源都空闲，也不分配给该进程，而让该进程等待。由于在该进程的等待期间，它并未占有任何资源，因而破坏了保持条件。 </p>
<p>破坏“不剥夺”条件<br>进程逐个地提出对资源的要求。 当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。 已经占有的资源，在运行过程中会被暂时地释放掉，从而破坏了“不剥夺”条件。 </p>
<p>破坏“环路等待”条件<br>系统将所有资源按类型分成不同等级进行排列，并赋予不同的等级号。例如，资源a序号为1，资源b的序号为2，资源c的序号为3，…。所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，破坏了“环路等待”条件。 这种方法称为有序资源分配法。</p>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>死锁的预防会牺牲系统的并发性能和资源的利用率，死锁避免通过合理的资源分配确保不会出现循环等待的条件，除了能够避免死锁，还能够支持进程的并发及资源的合理使用。并且死锁避免的过程是动态的，没有强制和预先设置的规则。</p>
<h6 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h6><p>基本思想：先判断系统是否处于安全状态，然后试探性地接受一个进程的资源请求，试探性分配资源，计算分配之后剩余的可用资源是否能满足系统中其他进程的需要，并且是否有进程能够获取足够多的资源来完成进程，释放资源。<br>如果考虑了完成进程的资源释放和其他进程的需求，能够最终使得每个进程都能够顺利完成，则将真正实施该进程的分配需求；否则，说明系统将处于不安全状态，不会真正实施该分配需求，等待其他进程的资源申请。</p>
<h6 id="死算检测和恢复"><a href="#死算检测和恢复" class="headerlink" title="死算检测和恢复"></a>死算检测和恢复</h6><p>在资源分配的时候考虑一定的限制，对死锁的预防和避免与一定的效果，但是资源的充分共享方面又会有所欠缺。与之相对应的解决方案是考虑死锁的检测和恢复，不影响资源的合理使用和分配。</p>
<p>当系统为进程分配资源时，没有采取任何限制性措施，那么系统必须检测系统内部是否出现死锁情况：<br>保存有关资源的请求和分配信息；<br>提供一种算法通过这些信息来检测系统是否已进入死锁状态。<br>相关难点在于：何时以何种频率运行检测死锁的算法。<br>运行太频繁会浪费CPU的处理时间，运行太稀疏又会导致系统内部死锁情况长时间不能被发现。</p>
<p>当发现有进程死锁时，必须立即把它们从死锁状态中恢复出来。<br>死锁恢复方法<br>取消所有的死锁进程；<br>让每个死锁进程回退到某些安全性检查的时间点之前，并重新启动所有进程；<br>连续取消死锁进程直到不再存在死锁；<br>连续抢占资源直到不再存在死锁。</p>
<h2 id="五、内存管理"><a href="#五、内存管理" class="headerlink" title="五、内存管理"></a>五、内存管理</h2><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/b93249eaf32626ca675be65c09f2d104c7f39dc0.png" title="" alt="图片19.png" width="460">

<p>内存<br>           主存储器简称内存或主存，是计算机系统中的主要部件，用于保存进程运行时的程序和数据，也称可执行存储器。<br>寄存器<br>　　  寄存器具有与处理机相同的速度，故对寄存器的访问速度最快，完全能与CPU协调工作，但价格却十分昂贵，因此容量不可能做得很大。 </p>
<p>高速缓冲存储器<br>　　高速缓存是现代计算机结构中的一个重要部件，它是介于寄存器和存储器之间的存储器，主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数，这样可大幅度地提高程序执行速度。高速缓存容量远大于寄存器，而比内存约小两到三个数量级左右，从几十KB到几MB，访问速度快于主存储器。 </p>
<p>磁盘缓存<br>　　由于目前磁盘的I&#x2F;O速度远低于对主存的访问速度，为了缓和两者之间在速度上的不匹配，而设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数。但磁盘缓存与高速缓存不同，它本身并不是一种实际存在的存储器，而是利用主存中的部分存储空间暂时存放从磁盘中读出(或写入)的信息。主存也可以看作是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用，反之，数据也必须先存在主存中，才能输出到辅存。</p>
<h6 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h6><p>        一个逻辑地址空间的程序装入到物理地址空间时，由于两个空间不一致，需要进行地址变换，称为地址重定位。<br>　    此时，相对地址空间（也称为逻辑地址空间）通过地址重定位机构转换到绝对地址空间（也称为物理地址空间）。</p>
<h6 id="单一连续、固定分区、可变化分区分配"><a href="#单一连续、固定分区、可变化分区分配" class="headerlink" title="单一连续、固定分区、可变化分区分配"></a>单一连续、固定分区、可变化分区分配</h6><p>单一连续分区存储管理<br>           这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。<br>　　    在单道程序环境下，当时的存储器管理方式是把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常是放在内存的低址部分。而在用户区内存中，仅装有一道用户程序，即整个内存的用户空间由该程序独占。这样的存储器分配方式被称为单一连续分配方式。</p>
<p>固定分区管理<br>固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行。<br>当某一分区空闲时，便可以从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。</p>
<p>划分分区的方法　　</p>
<p>(1) 分区大小相等(指所有的内存分区大小相等)。　　</p>
<p>(2) 分区大小不等。将内存划分出多个较小的分区，适量的中等分区和少量的大分区。 　　内存分配　　</p>
<p>为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\d6421cdad702117fe6a9449a114a04c3327f4aa3.png" alt="图片20.png"></p>
<p>可变分区管理（动态分区管理）　　　<br>固定分区分配是最早的多道程序存储管理方式，由于每个分区的大小固定，必然会造成存储空间的浪费。<br>可变分区分配是指在系统运行的过程中根据作业对内存的实际需要，动态地为之分配内存空间的一种分区方法。<br>可变分区分配是在作业装入和处理过程中建立的分区，并使分区的大小与作业的大小相等。<br>分区的个数和大小不是固定不变的，而是根据装入的作业动态地划分。</p>
<h4 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h4><h6 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h6><p>该算法要求分区链以地址递增的次序链接。内存分配时，从链首开始顺序查找，直至找到一个能满足其大小要求的空闲区为止。然后，再按照作业的大小，从该区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲链中。 </p>
<p>  该算法倾向于优先利用内存中低址部分的空闲区，高址部分的很少利用，从而保留了高址部分的大空闲区，为以后到达的大作业分配大的内存空间创造了条件。但低址部分留下许多难以利用的很小的空闲区 ，每次查找又都从低址部分开始，这样，增加了查找开销。</p>
<h6 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h6><p> “最佳”的含义是指每次为作业分配内存时，总是把既能满足要求又是最小的空闲分区分配给作业，避免“大材小用”。为加速查询，该算法要求将所有的空闲区按其大小以递增的顺序链接成一空闲区链。这样，第一次找到的满足要求的空闲区，必然是最优的。<br>            孤立地看，这似乎是最佳的，但从宏观上看却不一定。因为每次分配后所切割下的剩余部分，总是最小的，在存储器中会留下许多难以利用的小空闲区。</p>
<h6 id="最差适应算法"><a href="#最差适应算法" class="headerlink" title="最差适应算法"></a>最差适应算法</h6><p>        由于最坏适应分配算法选择空闲分区的策略正好与最佳适应算法相反：它在扫描整个空闲分区表或链表时，总是挑选一个最大的空闲区，从中分割一部分存储空间给作业使用，以至于存储器中缺乏大的空闲分区，故把它称为是最坏适应算法。</p>
<p>        该算法要求将所有空闲分区，按容量从大到小的顺序，形成一空闲分区链，查找时，只要看第一个分区能否满足作业要求即可。</p>
<h6 id="循环首次适应算法"><a href="#循环首次适应算法" class="headerlink" title="循环首次适应算法"></a>循环首次适应算法</h6><p>由首次适应算法演变而来，分配内存时，不再每次从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直到找到第一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间。</p>
<p>为实现该算法，应设置一起始查询指针，并采用循环查找方式。该算法能使内存中的空闲分区分布得更均匀，减少查找空闲分区的开销，但这会缺乏大的空闲分区。</p>
<h6 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h6><p>        该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表的表头指针。<br>           该算法在搜索空闲分区时分二步：第一步是根据进程长度从索引表中找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配。</p>
<p> 优点：查找效率高。另外在进行空闲分区分配时，不会对任何分区产生分割，能保留大的空闲分区，同时也不会产生内存碎片。<br>缺点：在分区归还时算法比较复杂，系统开销较大。该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费越严重，整体上会造成可观的存储空间浪费，这是典型的以空间换时间的作法。</p>
<h6 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h6><p> 哈希算法是利用哈希快速查找的优点，以及空闲分区在可利用空闲分区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。        进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p>
<h6 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h6><p> 该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂(k为整数，l≤k≤m)，其中2l表示分配的最小块的尺寸，2m表示分配的最大的块的尺寸。通常， 2m是可供分配的整个内存的大小。</p>
<p>（1）开始时，可用于分配的整个空间被看成是一个大小为2m的块；</p>
<p>（2）如果请求的大小s满足2m-1 &lt; s &lt;&#x3D; 2m ，则分配整个空间；否则，该块被分成两个大小相等的伙伴，均为2m-1 ，如果有2m-2 &lt; s &lt;&#x3D; 2m-1 ，则给该请求分配两个伙伴中的一个，否则，其中的一个伙伴被继续分成两半。这个过程一直持续直到产生大于或等于s的最小块，并将其分配。</p>
<h4 id="页、块、页表、地址结构、分页地址变换、快表"><a href="#页、块、页表、地址结构、分页地址变换、快表" class="headerlink" title="页、块、页表、地址结构、分页地址变换、快表"></a>页、块、页表、地址结构、分页地址变换、快表</h4><p>如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是段，则称为分段存储管理方式。 </p>
<p><strong>分页存储管理方式。</strong> 该方式是将用户程序的地址空间划分成若干个固定大小的区域（称为页或页面）；相应地，内存空间也被划分成若干个物理块，页和块的大小相等，典型大小为1KB。这样，用户程序的任意页可放在内存的任一块。<br><strong>分段存储管理方式。</strong> 该方式是把用户程序的地址空间分成若干个大小不等的段，每段可定义一组相对完整的逻辑信息。进行存储分配时，以段为单位，段在内存中可以不邻接。<br><strong>段页式存储管理方式。</strong> 分页和分段两种存储管理方式相结合的产物。</p>
<p><strong>页面和物理块</strong>　　</p>
<p>(1) 页面。分页存储管理是将内存分成大小固定的若干块，一般每一块的大小为1KB、2KB或4KB，每个这样的内存块称为页或物理块。将逻辑空间划分成若干个页，并为每页加以编号，从第0页开始，第1页，第2页，……。同时，将内存的物理地址空间划分成若干个块，同样为它们加以编号。进程分配内存时，将进程中的若干个页分别装入到多个可以不相邻的物理块中。会产生“页内碎片”。　　</p>
<p>(2) 页面大小。 过小，一方面可以减小内存碎片，另一方面会使进程占用较多页面，导致进程页表项过长，占用大量内存；过大，会使页内碎片增大。 </p>
<p><strong>页表</strong><br>　　    在进行存储分配时，允许将进程的各个页离散地存储在内存中不同的物理块中，但系统应能保证进程的正确运行。<br>　页表中至少应包含以下信息：<br>　(1) 页号：进程各页的序号；<br>　(2) 物理块号：进程各页对应存放在内存中的物理块的块号。</p>
<p><strong>地址变换过程</strong></p>
<p> 地址变换机构的基本任务是实现逻辑地址到物理地址的转换。由于页内地址与块内物理地址是一一对应的，故无须再转换。因此地址变换机构的任务，实际上是将逻辑地址中的页号，转换为内存中的物理块号。又因为页面映射表的作用就是用于实现从页号到物理块号的变换，所以地址变换任务是借助于页表来完成的。</p>
<p>页表的功能可以由一组专门的寄存器来实现，一个页表项用一个寄存器。但现代计算机系统大多都将页表驻留在内存，并设置一个页表寄存器PTR(Page-Table Register)，用于存放页表在内存的始址和页表的长度。</p>
<p>进程要访问某个逻辑地址中的数据时。</p>
<p>（1）分页地址机构自动地将有效地址分为页号和页内地址两部分；</p>
<p>（2）再以页号为索引去检索页表；</p>
<p>（3）将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是从中得到该页的物理块号，将之装入物理地址寄存器中；</p>
<p>（4）同时再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中。</p>
<p><strong>快表</strong></p>
<p>    由于页表作为数据本身是存放在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据(或向此地址中写入数据)。因此，采用这种方式将使计算机的处理速度降低近1&#x2F;2。可见，以此高昂代价来换取存储器空间利用率的提高，是得不偿失的。</p>
<p>            为提高地址变换速度，可在地址变换机构中增设一个称为快表的高速缓冲存储器，用以存放当前访问的页表项。<br>           此时地址变换过程是：CPU给出有效地址后，地址变换机构自动地将页号P送入快表高速缓存，并与其中的所有页号比较，若有与此相匹配的页号，则直接读出该页所对应的物理块号，送物理地址寄存器。若未找到，则再访问内存中的页表，找到后，把从页表项中读出的物理块号送地址寄存器；同时将此页表项存入快表。若快表已满，OS须找到一个老的且已被认为不再需要的页表项将它换出。</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\561540b15d3eef435faac3a94ebebd72420948db.png" alt="图片21.png"></p>
<p>假如查找快表需要20ns，访问内存需要100ns，那么总的访问时间是120ns。如果不能在快表中找到该页表项，那么必须先访问位于内存中的页表得到相应的物理块号(花费120ns)，然后再访问内存(花费100ns)，总共需要220ns。则：<br>      EAT＝0.85×(20+100)＋(1-0.85)×(20+200)＝135ns</p>
<h6 id="两级页表、多级页表"><a href="#两级页表、多级页表" class="headerlink" title="两级页表、多级页表"></a>两级页表、多级页表</h6><p>两级页表<br>        对于要求连续的内存空间来存放页表的问题，可以利用将页表进行分页，并离散的将各个页面分别存放在不同的物理块中的办法来加以解决，同样也要为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table) ，在每个页表项中记录了页表页面的物理块号。</p>
<p>多级页表<br>随着64位机器的普及，两级页表会出现外部页表非常大，要占用相当大的内存空间的问题。<br>可以采用三级或三级以上页表的方式，将原来两级页表中的外部页表再进行分页，然后利用第二级的外层页表来映射页表之间的关系。<br>多级页表类似于多级目录。<br>UNIX系统中使用了三级页表来实现地址映射。</p>
<h4 id="段、段表、地址结构、分段地址变换"><a href="#段、段表、地址结构、分段地址变换" class="headerlink" title="段、段表、地址结构、分段地址变换"></a>段、段表、地址结构、分段地址变换</h4><p>动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在分段式存储管理系统中则以段为单位分配内存，每段分配一个连续的内存区域，但各段之间不要求连续。<br>        其内存的分配和回收类似于动态分区分配方式，但两者之间也有不同。在分段存储管理系统中，一个作业可以有多个段，这些段允许离散地存放在内存的不同分区当中，而分区存储管理方式则要求整个作业存放在一个内存分区中。</p>
<p><strong>段表</strong></p>
<p>        作业的一个段被分配一个连续的分区，而进程中的各个段可以离散地放入内存中不同的分区中，为能从物理内存中找出每个逻辑段所对应的位置，在系统中为每个进程建立一张段映射表，简称段表。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址（基址）和段的长度（段长）。段表可以存放在一组寄存器中，更常见的是存放在内存中。</p>
<h4 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h4><p>分页和分段系统有许多相似之处，但在概念上二者完全不同：<br>(1) 页是信息的物理单位，仅仅是出于系统管理的需要；段是信息的逻辑单位，其目的是满足用户的需要。<br>(2) 页的大小固定且由系统确定，一个系统只能有一种大小的页面；段的长度不固定，决定于用户所编写的程序；<br>(3) 分页的作业地址空间是一维的；分段的作业地址空间是二维的。<br>(4) 通常分段的段内空间会比分页的页面空间大，因此段表会比页表短。</p>
<h6 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h6><p>基本原理<br>            段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成</p>
<p>   为实现从逻辑地址到物理地址的变换，系统需同时配置段表和页表，段表的内容是页表始址和页表长度，这与分段式系统不同。</p>
<img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="file:///C:/Blog/source/_posts/image/b47d6688f6e2e672f70ecddb9d3a0dbe07a89cfc.png" title="" alt="图片22.png" width="562">

<p>地址变换过程<br>        在段页式系统中，为了便于实现地址变换，需要配置一个段表寄存器，其中存放段表始址和段表长度。进行地址变换时按如下步骤进行：<br>(1) 通过段表寄存器将段号与段表长度进行比较，如果未越界则查找段表在内存中的位置，否则越界中断；<br>(2) 访问段表，将页表长度与页号进行比较，如果未越界则根据段号查找页表所在的位置；<br>(3) 访问页表，根据页号查找该页所在的物理块号；<br>(4) 将物理块号和地址结构中的页内地址相加，形成内存单元的物理地址。</p>
<p><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="C:\Blog\source_posts\image\f75a5fb533c54bb320279f1026da463f95e5f480.png" alt="图片23.png"></p>
<h6 id="基本原理：局部性原理、虚拟存储器"><a href="#基本原理：局部性原理、虚拟存储器" class="headerlink" title="基本原理：局部性原理、虚拟存储器"></a>基本原理：局部性原理、虚拟存储器</h6><p><strong>局部性原理</strong></p>
<p>程序运行时存在的局部性现象，很早就已被人发现，但直到1968年，P.Denning才真正指出：程序在执行时将呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。</p>
<p> 局限性又表现在下述两个方面：</p>
<p>(1) 时间局限性。程序中的某条指令被执行，不久后会再次执行；某个数据被访问，不久后将再次被访问。产生时间局限性的典型原因是在程序中存在着大量的循环操作。　　(2) 空间局限性。 程序访问了某个存储单元，不久后，其附近的存储单元也将被访问。</p>
<p><strong>虚拟存储器</strong></p>
<p>基于局部性原理可知，应用程序在运行之前没有必要将之全部装入内存，而仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。<br>        局部性原理是实现虚拟存储管理的理论基础。<br>        所谓虚拟存储器是指仅把作业的一部分装入内存便可运行的存储器系统，是具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。虚拟存储器的逻辑容量由系统的寻址能力和外存容量之和所决定，与实际的内存容量无关。</p>
<p>虚拟存储特征　</p>
<p>(1) 多次性：是指一个作业被分成多次来调入内存，即作业运行时不需将其全部装入内存，只需将当前要运行的那部分程序和数据装入，以后运行到某些部分时再将其调入。 (2) 对换性：是指允许作业中的程序和数据，在作业运行过程中换进、换出。</p>
<p>(3) 虚拟性：是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</p>
<p> 虚拟性以多次性和对换性为基础，多次性和对换性以离散分配为基础。</p>
<h6 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h6><p> 每当所要访问的页面不在内存时，便要产生一次缺页中断，请求OS将所缺之页调入内存。缺页中断虽要经历与一般中断相同的几个步骤，但它是一种特殊的中断，与一般中断的区别主要是：</p>
<p> (1) 在指令执行期间产生和处理中断信号。通常CPU都是在一条指令执行完后去检查是否有中断请求到达。有则响应，无则继续执行下一条指令。而缺页中断是在指令执行期间，发现所要访问的指令和数据不在内存时产生和处理的。</p>
<p> (2) 一条指令在执行期间，可能产生多次缺页中断。这时硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。</p>
<h4 id="页面置换算法：最佳置换、FIFO、LRU、第二次机会、CLOCK-置换"><a href="#页面置换算法：最佳置换、FIFO、LRU、第二次机会、CLOCK-置换" class="headerlink" title="页面置换算法：最佳置换、FIFO、LRU、第二次机会、CLOCK 置换"></a>页面置换算法：最佳置换、FIFO、LRU、第二次机会、CLOCK 置换</h4><h6 id="请求分页存储管理系统性能分析：缺页率、抖动、页面大小"><a href="#请求分页存储管理系统性能分析：缺页率、抖动、页面大小" class="headerlink" title="请求分页存储管理系统性能分析：缺页率、抖动、页面大小"></a>请求分页存储管理系统性能分析：缺页率、抖动、页面大小</h6><p>缺页率的影响因素: 1) 页面大小；2) 进程分配物理块的数目；3) 页面置换算法；4) 程序固有特性。</p>
<p>假设使用了“快表”以提高访问内存的速度，则CPU访问内存所花费的时间由以下3个部分组成：<br>(1) 页面在“快表”时的存取时间，只需1个读写周期时间；<br>(2) 页面不在“快表”而在页表时的存取时间，需要2个读写周期时间；<br>(3) 页面既不在“快表”也不在页表时，发生缺页中断处理的时间。<br>        缺页中断处理的时间又有3个部分组成：<br>(1) 缺页中断服务时间；<br>(2) 页面传送时间，包括：寻道时间、旋转时间和数据传送时间。<br>(3) 进程重新执行时间。</p>
<p>置换算法的好坏将直接影响系统的性能，不适当的算法可能导致进程发生“抖动” (Thrash-ing)。即刚被换出的页很快又被访问，需重新调入。为此，又需再选一页调出；而此刚被换出的页，很快又被访问，因而又需将它调入。如此频繁地更换页面，以至一个进程在运行中，将把大部分时间花在完成页面置换的工作上，我们称该进程发生了“抖动”。      抖动现象分为局部抖动和全局抖动两种类型。抖动现象如下两种类型：<br>        1) 局部抖动：进程采用局部置换策略，产生缺页时，只能置换自身拥有的某个页面，而不能置换其它进程的页面<br>        2) 全局抖动：由进程之间的相互作用引起的，若进程采用的是全局置换策略，当一个进程发生缺页中断时，需要从其它进程那里获取物理块，从而导致这些进程在运行中需要物理块，产生了缺页中断时，又需要从其它进程那里获取物理块。</p>
<p>页面大小的选择<br>页面大小的选择涉及到内部碎片、页表大小、页面失效率的高低等诸多问题<br>页面越小，内部碎片就越少，内存利用率就越高，但同时就会产生较大的页表，占用较大的内存空间；<br>页面过大，会导致页面在内外存之间传输时间的增加，从而降低了系统的有效访问时间；<br>页面较小，内存中包含的页面数就较多，相应的，缺页率就会较低，但随着页面的增大，缺页率也会随之升高，当页面大小超过进程的大小时，缺页率又开始下降。<br>选择最优的页面大小需要在这几个互相矛盾的因素之间权衡利弊。另外，页面的大小还与主存的大小、程序设计技术和程序结构以及快表等因素有关。</p>
<h6 id="请求分段存储管理"><a href="#请求分段存储管理" class="headerlink" title="请求分段存储管理"></a>请求分段存储管理</h6><p>请求分段存储管理系统是在分段存储管理系统的基础上增加了请求调段功能和段置换功能后所形成的分段虚拟存储管理系统。由于作业的各段是根据请求被装入内存的，因此，这种存储管理也称为请求分段存储管理。</p>
<p> 请求分段存储管理系统把作业的所有分段的副本都存放在外存中，当作业被调度投入执行时，先把当前需要的—段或几段装入内存。在执行过程中，出现缺段中断时，再把存储在外存上的段交换至内存，以此实现请求分段存储管理。</p>
<h2 id="六、设备管理"><a href="#六、设备管理" class="headerlink" title="六、设备管理"></a>六、设备管理</h2><h6 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6><h4 id="I-x2F-O系统控制方式"><a href="#I-x2F-O系统控制方式" class="headerlink" title="I&#x2F;O系统控制方式"></a>I&#x2F;O系统控制方式</h4><h6 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h6><h6 id="中断控制方式"><a href="#中断控制方式" class="headerlink" title="中断控制方式"></a>中断控制方式</h6><h6 id="DMA控制方式"><a href="#DMA控制方式" class="headerlink" title="DMA控制方式"></a>DMA控制方式</h6><h6 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h6><h4 id="通道类型"><a href="#通道类型" class="headerlink" title="通道类型"></a>通道类型</h4><h6 id="磁盘简述"><a href="#磁盘简述" class="headerlink" title="磁盘简述"></a>磁盘简述</h6><h4 id="磁盘调度：FCFS-SSTF-SCAN-C-SCAN-N步扫描，F-SCAN"><a href="#磁盘调度：FCFS-SSTF-SCAN-C-SCAN-N步扫描，F-SCAN" class="headerlink" title="磁盘调度：FCFS,SSTF,SCAN,C-SCAN,N步扫描，F-SCAN"></a>磁盘调度：FCFS,SSTF,SCAN,C-SCAN,N步扫描，F-SCAN</h4><h2 id="七、文件管理"><a href="#七、文件管理" class="headerlink" title="七、文件管理"></a>七、文件管理</h2><h6 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h6><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><ul>
<li><p>顺序结构</p>
</li>
<li><p>链接结构</p>
</li>
<li><p>索引结构</p>
</li>
<li><p>直接文件</p>
</li>
<li><p>哈希文件</p>
</li>
</ul>
<h6 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h6><h6 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h6><h6 id="目录查询"><a href="#目录查询" class="headerlink" title="目录查询"></a>目录查询</h6><h6 id="文件共享：符号链接实现共享、索引节点实现共享"><a href="#文件共享：符号链接实现共享、索引节点实现共享" class="headerlink" title="文件共享：符号链接实现共享、索引节点实现共享"></a>文件共享：符号链接实现共享、索引节点实现共享</h6><h6 id="文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法"><a href="#文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法" class="headerlink" title="文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法"></a>文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法</h6><h2 id="十、系统安全"><a href="#十、系统安全" class="headerlink" title="十、系统安全"></a>十、系统安全</h2><h6 id="逻辑炸弹、缓冲区溢出、SQP注入"><a href="#逻辑炸弹、缓冲区溢出、SQP注入" class="headerlink" title="逻辑炸弹、缓冲区溢出、SQP注入"></a>逻辑炸弹、缓冲区溢出、SQP注入</h6><p><strong>逻辑炸弹</strong>：逻辑炸弹是指在特定逻辑条件得到满足时实施破坏的计算机程序。可能造成计算机数据丢失、计算机无法从硬盘或软盘引导，甚至导致整个系统瘫痪，并出现物理损坏的虚假现象。<br>逻辑炸弹触发时的特定条件称为逻辑诱因。</p>
<p>逻辑炸弹的危害：直接破坏计算机软件产品的使用者的计算机数据。<br>引发连带的社会灾难，包括直接或间接的损失，如企业亏损、资料丢失、科学研究的永久性失败、当事人承受精神打击、刑事犯罪等。</p>
<p><strong>缓冲区溢出</strong>：是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，使得溢出的数据覆盖在合法数据上。理想的情况是，程序检查数据长度、同时不允许输入超过缓冲区长度的字符；然而绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出现象的发生埋下了隐患。<br>利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更严重的是，可以利用它执行非授权指令，甚至可以取得系统特权进而执行某些非法操作。</p>
<p><strong>SQL注入</strong>：是对数据库进行攻击的常用手段之一。<br>它利用现有应用程序可以将SQL命令注入到后台数据库引擎执行的能力，通过在Web表单、域名输入或页面请求的查询字符串等内容中输入恶意的SQL语句得到一个存在安全漏洞的网站的数据库，最终达到欺骗服务器执行恶意SQL命令的目的。<br>SQL注入攻击通过构建特殊的输入作为参数传入Web应用程序，而这些输入多为SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所需的操作，其发生原因主要是程序没有过滤用户输入的数据，致使非法数据侵入系统。<br>SQL注入可分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致过滤，从而执行了非法的数据查询。</p>
<h6 id="特洛伊木马、计算机病毒、蠕虫、rootkit"><a href="#特洛伊木马、计算机病毒、蠕虫、rootkit" class="headerlink" title="特洛伊木马、计算机病毒、蠕虫、rootkit"></a>特洛伊木马、计算机病毒、蠕虫、rootkit</h6><p><strong>特洛伊木马：</strong> 没有复制能力，其特点是伪装成一个实用工具或者一个可爱的游戏，诱使用户将其安装在PC或者服务器上。<br>在不经意间，特洛伊木马可能对使用者的计算机系统产生破坏，或窃取数据特别是使用者的各种账户及口令等重要且需要保密的信息，甚至直接控制计算机系统。一个完整的特洛伊木马套装程序包含两个部分：服务端（服务器部分）和客户端（控制器部分）。植入对方计算机的是服务端，而攻击者正是利用客户端进入运行了服务端的计算机。</p>
<p><strong>计算机病毒：</strong> 是指编制者在计算机程序中插入的、破坏计算机功能或者破坏数据、影响计算机使用并且能够自我复制的一组计算机指令或恶意的程序代码。<br>与生物病毒不相同的是，计算机病毒不是自然存在的生命体，而是某些人利用计算机软件或硬件固有的脆弱性编制出来的，其本质是一组指令集或程序代码。病毒能通过某种途径长期潜伏在计算机的存储介质（或程序）中，当达到某种条件时即被激活；同时，它还可以通过修改其他程序将自己的精确拷贝或者可能演化的形式植入其他程序中，从而感染更多程序。</p>
<p><strong>计算机病毒的特点</strong><br><strong>传染性</strong>是病毒的基本特征，是指计算机病毒在一定条件下可以自我复制，能对其它文件或系统进行一系列非法操作，并使之成为新的传染源。<br><strong>繁殖性</strong>：计算机病毒可以将与自身完全相同的副本植入其他程序或者存储介质的特定区域，使每一个受感染程序都同时包含病毒的一个克隆体。是否具备繁殖、感染的特征，是判断某一段程序为计算机病毒的首要条件。</p>
<p><strong>潜伏性</strong>：计算机病毒的潜伏性是指计算机病毒依附于其他载体寄生的一种能力，这使侵入的病毒可以潜伏在系统中直到条件成熟才会发作。<br>破坏性：所有的计算机病毒都是可执行程序，所以他们对计算机系统而言必然存在一个共同的危害，就是一旦执行便会占用系统资源，严重时会降低计算机系统工作效率。<br><strong>隐蔽性</strong>：计算机病毒通常具有很强的隐蔽性，这是计算机病毒难以被查杀的一个重要原因。<br><strong>可触发性</strong>：病毒因某个事件或数值的出现，诱使病毒实施感染或进行攻击的特性称为可触发性。</p>
<p><strong>计算机病毒、特洛伊木马与逻辑炸弹的比较</strong><br>在计算机程序中，病毒、木马与逻辑炸弹是常见的三种破坏手段，它们相互联系又各有区别。三者的共性在于它们都对计算机系统产生危害。<br>病毒是通过自我复制进行传播的计算机程序，自我复制是其基本特性，但它的破坏机制却不是必备的，所以现实中也存在一些只传染复制而不实施恶性破坏的、所谓的“良性”病毒。<br>木马虽然也是一种程序，但它只具备破坏性却不能完成自我复制。典型木马程序是以“冒充”来作为传播手段的，这同病毒在新目标中植入自己的副本这种“繁殖”方式显而易见存在差别。<br>逻辑炸弹一般隐含在具有正常功能的软件内部，并不像典型的木马程序那样仅仅只是模仿程序的外表而没有真正的程序功能。</p>
<h6 id="蠕虫"><a href="#蠕虫" class="headerlink" title="蠕虫"></a>蠕虫</h6><p>所谓蠕虫，又被称为蠕虫病毒，其实是一种结合了蠕虫特性与病毒机理（技术特点）的产物。目前主流的定义认为，蠕虫是一种能够利用系统漏洞通过网络进行自我传播的恶意程序。<br>蠕虫同时集成了蠕虫和病毒两者的特征，从而使其自身更加强大、传播能力也更强，它还有一个显著特点是不一定需要附着在其他程序上而可以独立存在。当形成规模与传播速度相当快时，蠕虫攻击会极大地消耗网络资源，从而导致大面积网络拥塞甚至瘫痪。</p>
<p>蠕虫分为主机蠕虫与网络蠕虫。其中，主机蠕虫完全包含在它们运行的计算机中，并且使用网络的连接将自身拷贝到其他的计算机中。主机蠕虫在完成自身的拷贝加入到另外的主机之后，就会终止自身的行为。<br>如果根据攻击目的进行划分，蠕虫又可以分成两类：一类是面对大规模计算机网络发动拒绝服务的计算机蠕虫，另一类则是针对个人用户的执行大量垃圾代码的计算机蠕虫。<br>蠕虫由两部分组成：一个主程序和一个引导程序。主程序一旦在电脑中建立就会去收集与当前电脑联网的其它主机信息。随后，主程序会尝试利用系统缺陷去在这些远程计算机上建立其引导程序。</p>
<h6 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a>rootkit</h6><p>rootkit一词最早出现在Unix系统中。系统入侵者为了取得系统管理员级的root权限或为了清除被系统记录的入侵痕迹，会重新汇编一些软件工具，这些工具就被称为kit。由此rootkit可以视作一项技术。<br>一种公认的定义认为：rootkit是指其主要功能为隐藏其他程式进程的软件，它可能是一个或多个软件的组合。从其定义不难看出，rootkit是一种特殊的恶意软件，其功能是在安装目标上隐藏自身及指定的文件、进程或网络链接等信息。目前，rootkit更多的是指那些被作为驱动程序加载到操作系统内核中的恶意软件。</p>
<p>通常情况下，rootkit总是和木马、后门等其他恶意程序结合使用。rootkit通过加载特殊的驱动、修改系统内核，进而达到隐藏信息的目的。<br>rootkit是一种奇特的程序，它具有隐身功能。无论是作为文件存在的静止时刻，还是作为进程存在的活动时刻都不会被察觉。<br>这一特性恰是一些人梦寐以求的——不论是计算机黑客，还是计算机取证人员。前者可以在入侵后置入rootkit，秘密窥探敏感信息或等待时机、伺机而动；后者则可以利用rootkit实时监控嫌疑人的不法行为，这不仅帮助搜集证据还有利于采取及时行动。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tjy531.com.cn">星星之火</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tjy531.com.cn/2023/05/25/%E8%80%83%E7%A0%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://tjy531.com.cn/2023/05/25/考研-操作系统/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tjy531.com.cn" target="_blank">好好学习，天天向上</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a></div><div class="post_share"><div class="social-share" data-image="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/waibaowebsite.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-transformer%E5%AD%A6%E4%B9%A0/" title="深度学习-transformer学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深度学习-transformer学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-tensor/" title="深度学习-tensor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深度学习-tensor</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/waibaowebsite.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">星星之火</div><div class="author-info__description">一万年太久，只争朝夕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TJY531"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TJY531" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3187937600@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">努力提升自己</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">一、 操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%EF%BC%9A%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%9F%BA%E6%9C%AC%E3%80%81%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%98%AF%E5%85%B6%E5%AE%83%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%94%AF%E6%92%91%E8%BD%AF%E4%BB%B6%E3%80%82%E5%AE%83%E6%8E%A7%E5%88%B6%E5%92%8C%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90%EF%BC%8C%E5%90%88%E7%90%86%E7%BB%84%E7%BB%87%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%B9%B6%E4%B8%BA%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8F%90%E4%BE%9B%E5%85%AC%E5%85%B1%E7%9A%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E3%80%82%E5%AE%83%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87%EF%BC%9A"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">操作系统定义：是计算机系统最基本、最重要的系统软件，是其它软件的支撑软件。它控制和管理计算机系统的硬件和软件资源，合理组织计算机工作流程，并为用户使用计算机提供公共的和基本的服务。它有以下两个主要目标：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">1.1.0.1.1.</span> <span class="toc-text">计算机系统的组成：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-number">1.1.0.1.2.</span> <span class="toc-text">操作系统与计算机系统：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.1.0.1.3.</span> <span class="toc-text">操作系统的发展过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.1.0.1.4.</span> <span class="toc-text">操作系统的主要功能：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-number">1.1.0.1.4.1.</span> <span class="toc-text">处理机管理：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-number">1.1.0.1.4.2.</span> <span class="toc-text">存储管理：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-number">1.1.0.1.4.3.</span> <span class="toc-text">设备管理：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-%EF%BC%9A"><span class="toc-number">1.1.0.1.4.4.</span> <span class="toc-text">文件管理 ：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">1.1.0.1.4.5.</span> <span class="toc-text">用户接口：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.1.0.1.5.</span> <span class="toc-text">操作系统结构：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7-%EF%BC%9A%E5%B9%B6%E5%8F%91%E3%80%81%E5%85%B1%E4%BA%AB%E3%80%81%E8%99%9A%E6%8B%9F%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">操作系统的特性 ：并发、共享、虚拟和异步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">二、中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.0.0.1.</span> <span class="toc-text">中断的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.0.0.2.</span> <span class="toc-text">中断的响应过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">中断的处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E7%8E%B0%E5%9C%BA%E5%92%8C%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.0.1.0.1.</span> <span class="toc-text">保护现场和传递参数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.0.1.0.2.</span> <span class="toc-text">执行相应的中断服务程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E7%8E%B0%E5%9C%BA%E5%B9%B6%E9%80%80%E5%87%BA%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.0.1.0.3.</span> <span class="toc-text">恢复现场并退出中断</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">三、 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">1.3.0.0.0.1.</span> <span class="toc-text">程序的顺序执行及其特征：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">1.3.0.0.0.2.</span> <span class="toc-text">程序的并发执行及其特征：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%AE%9E%E4%BD%93%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%92%8C%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E5%8D%95%E4%BD%8D%E3%80%82"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">进程的概念及其特征：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">进程状态：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.0.2.1.</span> <span class="toc-text">两状态模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.0.2.2.</span> <span class="toc-text">五状态模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.0.2.3.</span> <span class="toc-text">引入挂起状态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.3.0.2.3.1.</span> <span class="toc-text">进程控制块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.0.2.3.2.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.0.2.3.3.</span> <span class="toc-text">线程简介</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.0.3.0.1.</span> <span class="toc-text">线程实现与线程模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.0.3.0.2.</span> <span class="toc-text">线程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%EF%BC%9A%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E3%80%81%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AD%89%E5%A4%9A%E7%A7%8D%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">并发原理：临界资源、临界区等多种术语</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%9A%E6%98%AF%E4%B8%80%E6%AE%B5%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%B0%86%E5%9C%A8%E6%AD%A4%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90%EF%BC%8C%E5%BD%93%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%B7%B2%E7%BB%8F%E5%9C%A8%E8%AF%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%88%99%E8%AF%A5%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%83%BD%E5%9C%A8%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.0.4.0.1.</span> <span class="toc-text">临界区：是一段程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中运行时，则该进程不能在这段代码中执行</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89-%EF%BC%9A%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%9C%A8%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%AE%83%E4%BB%AC%E6%89%A7%E8%A1%8C%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%97%B6%E9%97%B4%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%85%B3%E7%B3%BB%E7%A7%B0%E4%B8%BA%E7%AB%9E%E4%BA%89"><span class="toc-number">1.3.0.4.0.2.</span> <span class="toc-text">竞争 ：多个进程在访问一个共享数据时，结果依赖于它们执行的相对时间，这种关系称为竞争</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%EF%BC%9A%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9C%89%E4%B8%80%E4%BA%9B%E7%9B%B8%E4%BA%92%E5%90%88%E4%BD%9C%E3%80%81%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%81%94%E7%B3%BB%E7%A7%B0%E4%B8%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.0.4.0.3.</span> <span class="toc-text">同步：系统中有一些相互合作、协同工作的进程，它们之间的相互联系称为进程的同步</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%EF%BC%9A%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%9B%A0%E4%BA%89%E7%94%A8%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%86%85%E7%9A%84%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%80%8C%E4%BA%92%E6%96%A5%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%8D%B3%E5%BD%93%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%9C%A8%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E6%97%B6%EF%BC%8C%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%83%BD%E8%BF%9B%E5%85%A5%E8%AF%A5%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%AE%BF%E9%97%AE%E4%BB%BB%E4%BD%95%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.0.4.0.4.</span> <span class="toc-text">互斥：多个进程因争用临界区内的共享资源而互斥的执行，即当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%88%96%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%9B%A0%E5%85%B6%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%83%BD%E5%9C%A8%E7%AD%89%E5%BE%85%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E8%80%8C%E4%B8%8D%E8%83%BD%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E6%83%85%E5%BD%A2%E7%A7%B0%E4%B8%BA%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.0.4.0.5.</span> <span class="toc-text">死锁：两个或两个以上的进程因其中的每个进程都在等待其它进程执行完毕而不能继续执行，这样的情形称为死锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF%EF%BC%9A%E6%98%AF%E6%8C%87%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%99%BD%E7%84%B6%E8%83%BD%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%86%E8%A2%AB%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E6%97%A0%E9%99%90%E6%9C%9F%E7%9A%84%E5%BF%BD%E8%A7%86%E8%80%8C%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.3.0.4.0.6.</span> <span class="toc-text">饥饿：是指一个可运行的进程虽然能继续执行，但被调度程序无限期的忽视而不能执行的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">硬件同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.0.6.0.1.</span> <span class="toc-text">管程机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.0.7.</span> <span class="toc-text">三个经典的进程同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.0.7.0.1.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.0.7.0.2.</span> <span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.0.7.0.3.</span> <span class="toc-text">哲学家就餐问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">1.3.0.7.0.4.</span> <span class="toc-text">消息传递</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">四、处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.0.0.0.1.</span> <span class="toc-text">调度简介</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%84%E6%BA%90"><span class="toc-number">1.4.0.1.0.1.</span> <span class="toc-text">资源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">死锁产生的原因和必要条件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A%E6%89%80%E8%B0%93%E6%AD%BB%E9%94%81-Deadlock-%EF%BC%8C%E6%98%AF%E6%8C%87%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%9B%A0%E7%AB%9E%E4%BA%89%E8%B5%84%E6%BA%90%E8%80%8C%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E7%A7%8D%E5%83%B5%E5%B1%80-Deadly-Embrace-%EF%BC%8C%E8%8B%A5%E6%97%A0%E5%A4%96%E5%8A%9B%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%BF%9B%E7%A8%8B%E5%B0%86%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%83%BD%E5%86%8D%E5%90%91%E5%89%8D%E6%8E%A8%E8%BF%9B%E3%80%82"><span class="toc-number">1.4.0.2.0.1.</span> <span class="toc-text">死锁的定义：所谓死锁 (Deadlock)，是指多个进程因竞争资源而造成的一种僵局(Deadly-Embrace)，若无外力作用，这些进程将永远不能再向前推进。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%A4%E5%AE%9A"><span class="toc-number">1.4.0.2.0.2.</span> <span class="toc-text">死锁的表示方法和判定</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">1.4.0.2.1.</span> <span class="toc-text">死锁预防</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.0.3.0.1.</span> <span class="toc-text">银行家算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E7%AE%97%E6%A3%80%E6%B5%8B%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.4.0.3.0.2.</span> <span class="toc-text">死算检测和恢复</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">五、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.0.0.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.5.0.0.0.2.</span> <span class="toc-text">地址重定位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E3%80%81%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E3%80%81%E5%8F%AF%E5%8F%98%E5%8C%96%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.5.0.0.0.3.</span> <span class="toc-text">单一连续、固定分区、可变化分区分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.0.1.0.1.</span> <span class="toc-text">首次适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.0.1.0.2.</span> <span class="toc-text">最佳适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%B7%AE%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.0.1.0.3.</span> <span class="toc-text">最差适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.0.1.0.4.</span> <span class="toc-text">循环首次适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.0.1.0.5.</span> <span class="toc-text">快速适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.0.1.0.6.</span> <span class="toc-text">哈希算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.0.1.0.7.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E3%80%81%E5%9D%97%E3%80%81%E9%A1%B5%E8%A1%A8%E3%80%81%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E3%80%81%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E3%80%81%E5%BF%AB%E8%A1%A8"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">页、块、页表、地址结构、分页地址变换、快表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E3%80%81%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.5.0.2.0.1.</span> <span class="toc-text">两级页表、多级页表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E3%80%81%E6%AE%B5%E8%A1%A8%E3%80%81%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E3%80%81%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">段、段表、地址结构、分段地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">分页和分段的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.0.4.0.1.</span> <span class="toc-text">段页式存储管理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9A%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E3%80%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.5.0.4.0.2.</span> <span class="toc-text">基本原理：局部性原理、虚拟存储器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.0.4.0.3.</span> <span class="toc-text">请求分页存储管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E3%80%81FIFO%E3%80%81LRU%E3%80%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E3%80%81CLOCK-%E7%BD%AE%E6%8D%A2"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">页面置换算法：最佳置换、FIFO、LRU、第二次机会、CLOCK 置换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%9A%E7%BC%BA%E9%A1%B5%E7%8E%87%E3%80%81%E6%8A%96%E5%8A%A8%E3%80%81%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.5.0.5.0.1.</span> <span class="toc-text">请求分页存储管理系统性能分析：缺页率、抖动、页面大小</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.0.5.0.2.</span> <span class="toc-text">请求分段存储管理</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">六、设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.6.0.0.0.1.</span> <span class="toc-text">概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-x2F-O%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">I&#x2F;O系统控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.0.1.0.1.</span> <span class="toc-text">程序直接控制方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.0.1.0.2.</span> <span class="toc-text">中断控制方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DMA%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.0.1.0.3.</span> <span class="toc-text">DMA控制方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.0.1.0.4.</span> <span class="toc-text">通道控制方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">通道类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%AE%80%E8%BF%B0"><span class="toc-number">1.6.0.2.0.1.</span> <span class="toc-text">磁盘简述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%EF%BC%9AFCFS-SSTF-SCAN-C-SCAN-N%E6%AD%A5%E6%89%AB%E6%8F%8F%EF%BC%8CF-SCAN"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">磁盘调度：FCFS,SSTF,SCAN,C-SCAN,N步扫描，F-SCAN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">七、文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.7.0.0.0.1.</span> <span class="toc-text">概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.7.0.1.0.1.</span> <span class="toc-text">文件控制块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.0.1.0.2.</span> <span class="toc-text">索引节点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.0.1.0.3.</span> <span class="toc-text">目录查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%EF%BC%9A%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E3%80%81%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB"><span class="toc-number">1.7.0.1.0.4.</span> <span class="toc-text">文件共享：符号链接实现共享、索引节点实现共享</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8%EF%BC%9A%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%98%B5%E3%80%81%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E8%A1%A8%E3%80%81%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%A1%A8%E3%80%81%E5%8F%A3%E4%BB%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.0.1.0.5.</span> <span class="toc-text">文件安全：存取控制矩阵、存取控制表、用户权限表、口令方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8"><span class="toc-number">1.8.</span> <span class="toc-text">十、系统安全</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%82%B8%E5%BC%B9%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E3%80%81SQP%E6%B3%A8%E5%85%A5"><span class="toc-number">1.8.0.0.0.1.</span> <span class="toc-text">逻辑炸弹、缓冲区溢出、SQP注入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%B4%9B%E4%BC%8A%E6%9C%A8%E9%A9%AC%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E3%80%81%E8%A0%95%E8%99%AB%E3%80%81rootkit"><span class="toc-number">1.8.0.0.0.2.</span> <span class="toc-text">特洛伊木马、计算机病毒、蠕虫、rootkit</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A0%95%E8%99%AB"><span class="toc-number">1.8.0.0.0.3.</span> <span class="toc-text">蠕虫</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#rootkit"><span class="toc-number">1.8.0.0.0.4.</span> <span class="toc-text">rootkit</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/25/Res2Net%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" title="Res2Net论文阅读记录">Res2Net论文阅读记录</a><time datetime="2025-02-25T12:56:50.000Z" title="发表于 2025-02-25 20:56:50">2025-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/22/%E5%8D%B7%E7%A7%AF/" title="卷积">卷积</a><time datetime="2025-02-22T02:45:06.000Z" title="发表于 2025-02-22 10:45:06">2025-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/20/EGE-UNet/" title="EGE-UNet 论文阅读记录">EGE-UNet 论文阅读记录</a><time datetime="2025-02-20T05:30:11.000Z" title="发表于 2025-02-20 13:30:11">2025-02-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/19/h2former%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" title="H2former论文阅读记录">H2former论文阅读记录</a><time datetime="2025-02-19T06:23:26.000Z" title="发表于 2025-02-19 14:23:26">2025-02-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/14/Camoformer%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" title="Camoformer论文阅读记录">Camoformer论文阅读记录</a><time datetime="2025-02-14T08:44:48.000Z" title="发表于 2025-02-14 16:44:48">2025-02-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 星星之火</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://comment.tjy531.com.cn/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, {"requiredMeta":["nick","mail"],"locale":{"placeholder":"昵称和邮箱为必填项，为了您能及时收到相关信息，请确保邮箱的正确性"}}))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="https://imagfromtjy.oss-cn-shenzhen.aliyuncs.com/img/loadingwebsite.gif" data-original="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const loadWaline = () => {
      Waline.RecentComments({
        serverURL: 'https://comment.tjy531.com.cn/',
        count: 6
      }).then(({comments}) => {
        const walineArray = comments.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.insertedAt,
          }
        })
        saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
        generateHtml(walineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
    }

    if (typeof Waline === 'object') loadWaline()
    else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(loadWaline)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="study?,study!,ok" data-fontsize="10px" data-random="true" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>